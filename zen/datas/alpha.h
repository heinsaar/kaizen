// MIT License
// 
// Copyright (c) 2023 Leo Heinsaar
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <queue>

namespace zen {

// At the moment kaizen.h is generated by dumping the contents of the constituent header files
// sorted in alphabetical order, so the name 'alpha.h' of the file is chosen such that its
// contents appear first in kaizen.h, so any downstream code can use it. This slighly breaks
// the principle of independence of all individual headers, but only to a first degree and
// seems to bring benefits that outweigh the cost of a slightly increased coupling.

///////////////////////////////////////////////////////////////////////////////////////////// MISC

// Quotes a string. This helps avoid cumbersome quote gymnastics in code.
// Example: quote(filename) + " does not exist";
// Result:  "/path/to/file" does not exist
inline std::string quote(const std::string_view s) { return '\"' + std::string(s) + '\"'; }

inline auto timestamp() {
    std::time_t result  = std::time(nullptr);
    std::string timestr = std::asctime(std::localtime(&result));
    return timestr.substr(0, timestr.length() - 1);
}

template<class T1, class T2>
std::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& p)
{
    return os << '[' << p.first << ", " << p.second << ']';
}

// Function to handle string serialization
template<typename T>
std::string serialize(const T& x) {
    std::ostringstream ss;
    ss << x;
    return ss.str();
}

// Overload for std::string type: serialization for a string type means
// simply quoting it, so that wherever it appears, it does so in quotes
std::string serialize(const std::string& s) { return quote(s); }

// Helper function to handle comma-space separator
template<typename Os, typename T, typename... Ts>
void tuple_to_stream(Os& os, const T& first, const Ts&... rest) {
    os << serialize(first);
    ((os << ", " << serialize(rest)), ...);
}

template<typename... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& tup) {
    os << "[";
    std::apply([&os](auto&&... args) {
        tuple_to_stream(os, args...);
        }, tup);
    os << "]";
    return os;
}

///////////////////////////////////////////////////////////////////////////////////////////// zen::stackonly

struct stackonly
{
    static void* operator new(  std::size_t) = delete;
    static void* operator new[](std::size_t) = delete;
    static void  operator delete(  void*)    = delete;
    static void  operator delete[](void*)    = delete;
};

///////////////////////////////////////////////////////////////////////////////////////////// TESTING

#define BEGIN_TEST    zen::log("BEGIN", zen::repeat("-", 50), __func__)
#define BEGIN_SUBTEST zen::log(         zen::repeat("-", 61), __func__)
#define END_TESTS     zen::log("END  ", zen::repeat("-", 50), __func__)

std::atomic<int> TEST_CASE_PASS_COUNT = 0; // atomic in case tests are ever parallelized
std::atomic<int> TEST_CASE_FAIL_COUNT = 0; // atomic in case tests are ever parallelized

bool REPORT_TC_PASS = false; // by default, don't report passes to avoid chatter
bool REPORT_TC_FAIL = true;  // by default, do    report fails (should be few)

#define ZEN_STATIC_ASSERT(X, M) static_assert(X, "ZEN STATIC ASSERTION FAILED. "#M ": " #X)

// ZEN_EXPECT checks its expression parameter and spits out the expression if it fails.
// The do { } while (0) construct ensures that the macro behaves as a single statement.
// This allows it to be used safely in contexts like if-else statements without braces,
// preventing syntax errors or unexpected behavior due to dangling elses.
// Continues execution regardless of the expectation result.
// Example: ZEN_EXPECT(str == "good");
// Result:  CASE PASS: ...
//     or:  CASE FAIL: ...
#define ZEN_EXPECT(expression) \
    do { \
        if (expression) { \
            if (zen::REPORT_TC_PASS) \
                zen::log(zen::color::green("CASE PASS:"), #expression); \
            ++zen::TEST_CASE_PASS_COUNT; \
        } \
        if (!(expression)) { \
            if (zen::REPORT_TC_FAIL) \
                zen::log(zen::color::red("CASE FAIL:"), __func__, "EXPECTED:", #expression); \
            ++zen::TEST_CASE_FAIL_COUNT; \
        } \
    } while (0)

// ZEN_EXPECT_THROW checks its expression parameter to throw the expression_type exception
// and spits out the expression statement if it encounters another exception type thrown.
// The do { } while (0) construct ensures that the macro behaves as a single statement.
// This allows it to be used safely in contexts like if-else statements without braces,
// preventing syntax errors or unexpected behavior due to dangling elses.
// Example: ZEN_EXPECT_THROW(zen::version vi("bad"), std::invalid_argument);
// Continues execution regardless of the expectation result.
// Result:  CASE PASS: ...
//     or:  CASE FAIL: ...
#define ZEN_EXPECT_THROW(expression, exception_type) \
    do { \
        bool exception_caught{false}; \
        try { \
            expression; \
        } \
        catch (const exception_type&) { \
            exception_caught = true; \
            if (zen::REPORT_TC_PASS) \
                zen::log(zen::color::green("CASE PASS:"), #expression); \
            ++zen::TEST_CASE_PASS_COUNT; \
            break; \
        } \
        catch (...) { \
            exception_caught = true; \
            if (zen::REPORT_TC_FAIL) \
                zen::log(zen::color::red("CASE FAIL:"), __func__, \
                        "EXPECTED `" #expression \
                        "` TO THROW AN EXCEPTION OF TYPE `" #exception_type \
                        "`, BUT IT THROWS ANOTHER TYPE."); \
            ++zen::TEST_CASE_FAIL_COUNT; \
            break; \
        } \
        if (!exception_caught) { \
            if (zen::REPORT_TC_FAIL) \
                zen::log(zen::color::red("CASE FAIL:"), __func__, \
                        "EXPECTED `" #expression \
                        "` TO THROW AN EXCEPTION, BUT IT DOES NOT."); \
            ++zen::TEST_CASE_FAIL_COUNT; \
        } \
    } while(0)

// ISSUE#25: Add ZEN_EXPECT_NOTHROW()

///////////////////////////////////////////////////////////////////////////////////////////// COLORS
// Example: zen::print(zen::color::red(str));
// Example: std::cout( zen::color::red(str));
// Result: Red-colored str in the console.
namespace color {
    class color_string {
    public:
        color_string(const std::string_view s, int c) : text(s), code(c) {}
        const std::string text;
        const int /*col*/ code;

        friend std::ostream& operator<<(std::ostream& os, const color_string& cw) {
            os << "\033[" << cw.code << "m" << cw.text << "\033[0m";
            return os;
        }
    };

    color_string nocolor(const std::string_view s) { return color_string(s,  0); }
    color_string red    (const std::string_view s) { return color_string(s, 31); }
    color_string blue   (const std::string_view s) { return color_string(s, 34); }
    color_string green  (const std::string_view s) { return color_string(s, 32); }
    color_string black  (const std::string_view s) { return color_string(s, 30); }
    color_string yellow (const std::string_view s) { return color_string(s, 33); }
    color_string magenta(const std::string_view s) { return color_string(s, 35); }
    color_string cyan   (const std::string_view s) { return color_string(s, 36); }
    color_string white  (const std::string_view s) { return color_string(s, 37); }
}

///////////////////////////////////////////////////////////////////////////////////////////// FILESYSTEM

std::filesystem::path current_path() { return std::filesystem::current_path(); }
std::filesystem::path  parent_path() { return std::filesystem::current_path().parent_path(); }

std::optional<std::filesystem::path>
search_upward(std::string_view name, std::filesystem::path from = std::filesystem::current_path())
{
    while (from.filename() != name) {
        if (from.root_path() == from && name == "/")
            return from;

        // In most file systems, attempting to go to the parent of the root
        // directory returns the root directory itself. Therefore, to avoid
        // potentially infinite loops when the search reaches the root
        // directory and still can't find the specified directory or file
        // handle, we check to see if the parent of 'from' is 'from' itself:
        std::filesystem::path parent = from.parent_path();
        if (from == parent)
            return std::nullopt;

        from = parent;
    }

    if (from.empty())
        return std::nullopt;
        
    return from;
}

std::optional<std::filesystem::path>
search_downward(std::string_view name, std::filesystem::path from = std::filesystem::current_path(), const int depth = 10)
{
    std::queue<std::pair<std::filesystem::path, int>> search_queue;
    search_queue.push({ from, 0 });

    while (!search_queue.empty()) {
        const auto [current_path, current_depth] = search_queue.front();
        search_queue.pop();

        if (current_path.filename() == name)
            return current_path;

        if (current_depth >= depth)
            continue;

        if (std::filesystem::is_directory(current_path))
            for (const auto& entry : std::filesystem::directory_iterator(current_path))
                search_queue.push({ entry.path(), current_depth + 1 });
    }

    return std::nullopt;
}

} // namespace zen