// MIT License
// 
// Copyright (c) 2023 Leo Heinsaar
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <queue>
#include<string>

namespace zen {

// At the moment kaizen.h is generated by dumping the contents of the constituent header files
// sorted in alphabetical order, so the name 'alpha.h' of the file is chosen such that its
// contents appear first in kaizen.h, so any downstream code can use it. This slighly breaks
// the principle of independence of all individual headers, but only to a first degree and
// seems to bring benefits that outweigh the cost of a slightly increased coupling.

///////////////////////////////////////////////////////////////////////////////////////////// MISC

// Quotes a string. This helps avoid cumbersome quote gymnastics in code.
// Example: quote(filename) + " does not exist";
// Result:  "/path/to/file" does not exist
inline std::string quote(const std::string_view s) { return '\"' + std::string(s) + '\"'; }

inline auto timestamp() {
    std::time_t result  = std::time(nullptr);
    std::string timestr = std::asctime(std::localtime(&result));
    return timestr.substr(0, timestr.length() - 1);
}

///////////////////////////////////////////////////////////////////////////////////////////// SERIALIZATION

template <class T> constexpr bool is_string_like(); // forward declaration

//------------------------------------------------------------------------------------------- std::pair

namespace internal {
    template<class T>
    std::string serialize(const T& x) {
        std::ostringstream ss;
        if constexpr (is_string_like<T>())
            ss << quote(x);
        else
            ss << x;
        return ss.str();
    }

    // Overload for std::string type: serialization for a string type means
    // simply quoting it, so that wherever it appears, it does so in quotes
    std::string serialize(const std::string& s) { return quote(s); }

    // Helper function to handle pair serialization
    template<class T1, class T2>
    std::string serialize(const std::pair<T1, T2>& p) {
        return "{" + serialize(p.first) + ", " + serialize(p.second) + "}";
    }

    // Helper function to handle pair stream output
    template<class Os, class T1, class T2>
    void pair_to_stream(Os& os, const std::pair<T1, T2>& p) {
        os << serialize(p.first) << ", " << serialize(p.second);
    }
} // namespace internal

template<class T1, class T2>
std::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& p) {
    os << "{";
    internal::pair_to_stream(os, p);
    os << "}";
    return os;
}

//------------------------------------------------------------------------------------------- std::tuple

namespace internal {
    template<class... Ts>
    std::string serialize(const std::tuple<Ts...>& tup) {
        std::string s = "{";
        std::apply([&s](auto&&... args) {
            auto append = [&](const auto& arg) { s += serialize(arg) + ", "; };
            (append(args), ...);
        }, tup);
        if (s.size() > 1)
            s.erase(s.size() - 2); // remove trailing ", "
        return s + "}";
    }
    // Helper function to handle comma-space separator
    template<class Os, class T, class... Ts>
    void tuple_to_stream(Os& os, const T& first, const Ts&... rest) {
        os << serialize(first);
        ((os << ", " << serialize(rest)), ...);
    }
} // namespace internal

template<class... Ts>
std::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& tup) {
    os << "{";
    std::apply([&os](auto&&... args) {
        internal::tuple_to_stream(os, args...);
        }, tup);
    os << "}";
    return os;
}

///////////////////////////////////////////////////////////////////////////////////////////// zen::stackonly

struct stackonly
{
    static void* operator new(  std::size_t) = delete;
    static void* operator new[](std::size_t) = delete;
    static void  operator delete(  void*)    = delete;
    static void  operator delete[](void*)    = delete;
};

///////////////////////////////////////////////////////////////////////////////////////////// TESTING

#define BEGIN_TEST    zen::log("BEGIN", zen::repeat("-", 50), __func__)
#define BEGIN_SUBTEST zen::log(         zen::repeat("-", 61), __func__)
#define END_TESTS     zen::log("END  ", zen::repeat("-", 50), __func__)

std::atomic<int> TEST_CASE_PASS_COUNT = 0; // atomic in case tests are ever parallelized
std::atomic<int> TEST_CASE_FAIL_COUNT = 0; // atomic in case tests are ever parallelized

bool REPORT_TC_PASS = false; // by default, don't report passes to avoid excessive chatter
bool REPORT_TC_FAIL = true;  // by default, do    report fails (should be few)

#define ZEN_STATIC_ASSERT(X, M) static_assert(X, "ZEN STATIC ASSERTION FAILED. "#M ": " #X)

// ZEN_EXPECT checks its expression parameter and spits out the expression if it fails.
// The do { } while (0) construct ensures that the macro behaves as a single statement.
// This allows it to be used safely in contexts like if-else statements without braces,
// preventing syntax errors or unexpected behavior due to dangling elses.
// Continues execution regardless of the expectation result.
// Example: ZEN_EXPECT(str == "good");
// Result:  CASE PASS: ...
//     or:  CASE FAIL: ...

#define EQ(expected, actual) ((expected) == (actual))
#define IS_TRUE(expression) ((expression))
#define IS_FALSE(expression) (!(expression))
#define GT(value, other) ((value) > (other))
#define LT(value, other) ((value) < (other))
#define GE(value, other) ((value) >= (other))
#define LE(value, other) ((value) <= (other))
#define AND(condition1, condition2) ((condition1) && (condition2))
#define OR(condition1, condition2) ((condition1) || (condition2))
#define EXPECT_FLOAT_EQ(expected, actual, epsilon) (fabs((expected) - (actual)) < (epsilon))
#define EXPECT_DOUBLE_EQ(expected, actual, epsilon) (fabs((expected) - (actual)) < (epsilon))

#define ZEN_EXPECT(expression) \
    do { \
        bool result = (expression); \
        if (result) { \
            if (zen::REPORT_TC_PASS) \
                zen::log(zen::color::green("CASE PASS:"), #expression); \
            ++zen::TEST_CASE_PASS_COUNT; \
        } else { \
            if (zen::REPORT_TC_FAIL) { \
                zen::log(zen::color::red("CASE FAIL:"), __func__, "EXPECTED:", #expression); \
            } \
            ++zen::TEST_CASE_FAIL_COUNT; \
        } \
    } while (0)

// ZEN_EXPECT_THROW checks its expression parameter to throw the expression_type exception
// and spits out the expression statement if it encounters another exception type thrown.
// The do { } while (0) construct ensures that the macro behaves as a single statement.
// This allows it to be used safely in contexts like if-else statements without braces,
// preventing syntax errors or unexpected behavior due to dangling elses.
// Example: ZEN_EXPECT_THROW(zen::version vi("bad"), std::invalid_argument);
// Continues execution regardless of the expectation result.
// Result:  CASE PASS: ...
//     or:  CASE FAIL: ...
#define ZEN_EXPECT_THROW(expression, exception_type) \
    do { \
        bool exception_caught{false}; \
        try { \
            expression; \
        } \
        catch (const exception_type&) { \
            exception_caught = true; \
            if (zen::REPORT_TC_PASS) \
                zen::log(zen::color::green("CASE PASS:"), #expression); \
            ++zen::TEST_CASE_PASS_COUNT; \
            break; \
        } \
        catch (...) { \
            exception_caught = true; \
            if (zen::REPORT_TC_FAIL) \
                zen::log(zen::color::red("CASE FAIL:"), __func__, \
                        "EXPECTED `" #expression \
                        "` TO THROW AN EXCEPTION OF TYPE `" #exception_type \
                        "`, BUT IT THROWS ANOTHER TYPE."); \
            ++zen::TEST_CASE_FAIL_COUNT; \
            break; \
        } \
        if (!exception_caught) { \
            if (zen::REPORT_TC_FAIL) \
                zen::log(zen::color::red("CASE FAIL:"), __func__, \
                        "EXPECTED `" #expression \
                        "` TO THROW AN EXCEPTION, BUT IT DOES NOT."); \
            ++zen::TEST_CASE_FAIL_COUNT; \
        } \
    } while(0)

// ZEN_EXPECT_NOTHROW checks its expression parameter to not throw an exception
// and spits out the expression statement if it an exception is, in fact, thrown.
// The do { } while (0) construct ensures that the macro behaves as a single statement.
// This allows it to be used safely in contexts like if-else statements without braces,
// preventing syntax errors or unexpected behavior due to dangling elses.
// Example: ZEN_EXPECT_NOTHROW(no_throw_function());
// Continues execution regardless of the expectation result.
// Result:  CASE PASS: ...
//     or:  CASE FAIL: ...
#define ZEN_EXPECT_NOTHROW(expression) \
    do { \
        bool exception_caught{false}; \
        try { \
            expression; \
        } \
        catch (...) { \
            exception_caught = true; \
            if (zen::REPORT_TC_FAIL) \
                zen::log(zen::color::red("CASE FAIL:"), __func__, \
                        "EXPECTED `" #expression "` NOT TO THROW ANY EXCEPTION, BUT IT DID."); \
            ++zen::TEST_CASE_FAIL_COUNT; \
            break; \
        } \
        if (!exception_caught) { \
            if (zen::REPORT_TC_PASS) \
                zen::log(zen::color::green("CASE PASS:"), #expression); \
            ++zen::TEST_CASE_PASS_COUNT; \
        } \
    } while(0)

///////////////////////////////////////////////////////////////////////////////////////////// COLORS
// Example: zen::print(zen::color::red(str));
// Example: std::cout( zen::color::red(str));
// Result: Red-colored str in the console.
namespace color {
    class color_string {
    public:
        color_string(const std::string_view s, int c) : text(s), code(c) {}
        const std::string text;
        const int /*col*/ code;

        friend std::ostream& operator<<(std::ostream& os, const color_string& cw) {
            os << "\033[" << cw.code << "m" << cw.text << "\033[0m";
            return os;
        }
    };

    color_string nocolor(const std::string_view s) { return color_string(s,  0); }
    color_string red    (const std::string_view s) { return color_string(s, 31); }
    color_string blue   (const std::string_view s) { return color_string(s, 34); }
    color_string green  (const std::string_view s) { return color_string(s, 32); }
    color_string black  (const std::string_view s) { return color_string(s, 30); }
    color_string yellow (const std::string_view s) { return color_string(s, 33); }
    color_string magenta(const std::string_view s) { return color_string(s, 35); }
    color_string cyan   (const std::string_view s) { return color_string(s, 36); }
    color_string white  (const std::string_view s) { return color_string(s, 37); }
}

///////////////////////////////////////////////////////////////////////////////////////////// FILESYSTEM

std::filesystem::path current_path() { return std::filesystem::current_path(); }
std::filesystem::path  parent_path() { return std::filesystem::current_path().parent_path(); }

std::optional<std::filesystem::path>
search_upward(std::string_view name, std::filesystem::path from = std::filesystem::current_path())
{
    while (from.filename() != name) {
        if (from.root_path() == from && name == "/")
            return from;

        // In most file systems, attempting to go to the parent of the root
        // directory returns the root directory itself. Therefore, to avoid
        // potentially infinite loops when the search reaches the root
        // directory and still can't find the specified directory or file
        // handle, we check to see if the parent of 'from' is 'from' itself:
        std::filesystem::path parent = from.parent_path();
        if (from == parent)
            return std::nullopt;

        from = parent;
    }

    if (from.empty())
        return std::nullopt;
        
    return from;
}

std::optional<std::filesystem::path>
search_downward(std::string_view name, std::filesystem::path from = std::filesystem::current_path(), const int depth = 10)
{
    std::queue<std::pair<std::filesystem::path, int>> search_queue;
    search_queue.push({ from, 0 });

    while (!search_queue.empty()) {
        const auto [current_path, current_depth] = search_queue.front();
        search_queue.pop();

        if (current_path.filename() == name)
            return current_path;

        if (current_depth >= depth)
            continue;

        if (std::filesystem::is_directory(current_path))
            for (const auto& entry : std::filesystem::directory_iterator(current_path))
                search_queue.push({ entry.path(), current_depth + 1 });
    }

    return std::nullopt;
}

} // namespace zen
